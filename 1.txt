第1章　RISC-V体系结构基础知识 1
    1.1　RISC-V介绍 1
        1.1.1　RISC-V指令集优点 1
        1.1.2　RISC-V指令集扩展 2
        1.1.3　RISC-V商业化发展 2
    1.2　RISC-V体系结构介绍 3
        1.2.1　RISC-V体系结构 3
        1.2.2　采用RISC-V体系结构的常见处理器 3
        1.2.3　RISC-V体系结构中的基本概念 4
        1.2.4　SBI服务 5
    1.3　RISC-V寄存器 6
        1.3.1　通用寄存器 6
        1.3.2　系统寄存器 7
        1.3.3　U模式下的系统寄存器 8
        1.3.4　S模式下的系统寄存器 9
        1.3.5　M模式下的系统寄存器 11
    1.4　香山处理器介绍 15
        1.4.1　香山处理器体系结构 15
        1.4.2　香山处理器的前端子系统 16
        1.4.3　香山处理器的后端子系统 18
        1.4.4　香山处理器的访存子系统 20
        1.4.5　香山处理器的L2/L3高速缓存 25
第2章　搭建RISC-V实验环境 29
    2.1　实验平台 29
        2.1.1　QEMU 29
        2.1.2　NEMU 30
    2.2　搭建实验环境 31
        2.2.1　实验2-1：输出“Welcome RISC-V!” 31
        2.2.2　实验2-2：单步调试BenOS和MySBI 32
    2.3　BenOS和MySBI基础实验代码解析 34
        2.3.1　MySBI基础代码分析 34
        2.3.2　BenOS基础代码分析 37
        2.3.3　合并BenOS和MySBI 41
    2.4　QEMU + RISC-V + Linux实验平台 41
第3章　基础指令集 44
    3.1　RISC-V指令集介绍 44
    3.2　RISC-V指令编码格式 45
    3.3　加载与存储指令 46
    3.4　PC相对寻址 49
    3.5　移位操作 53
    3.6　位操作指令 55
    3.7　算术指令 56
    3.8　比较指令 57
    3.9　无条件跳转指令 58
    3.10　条件跳转指令 59
    3.11　CSR指令 61
    3.12　寻址范围 62
    3.13　陷阱：为什么ret之后就进入死循环 62
    3.14　实验 64
        3.14.1　实验3-1：熟悉加载指令 64
        3.14.2　实验3-2：PC相对地址寻址 64
        3.14.3　实验3-3：memcpy()函数的实现 65
        3.14.4　实验3-4：memset()函数的实现 65
        3.14.5　实验3-5：条件跳转指令1 65
        3.14.6　实验3-6：条件跳转指令2 66
        3.14.7　实验3-7：子函数跳转 66
        3.14.8　实验3-8：在汇编中实现串口输出功能 66
第4章　函数调用规范与栈 67
    4.1　函数调用规范 67
    4.2　入栈与出栈 70
    4.3　RISC-V栈的布局 72
        4.3.1　不使用FP的栈布局 72
        4.3.2　使用FP的栈布局 74
        4.3.3　栈回溯 76
    4.4　实验 78
        4.4.1　实验4-1：观察栈布局 78
        4.4.2　实验4-2：观察栈回溯 78
第5章　GNU汇编器 79
    5.1　编译流程与ELF文件 79
    5.2　一个简单的汇编程序 82
    5.3　汇编语法 84
        5.3.1　注释 84
        5.3.2　符号 84
    5.4　常用的伪指令 85
        5.4.1　对齐伪指令 85
        5.4.2　数据定义伪指令 86
        5.4.3　与函数相关的伪指令 87
        5.4.4　与段相关的伪指令 87
        5.4.5　与宏相关的伪指令 89
        5.4.6　与文件相关的伪指令 91
    5.5　RISC-V依赖特性 91
        5.5.1　RISC-V特有的命令行选项 91
        5.5.2　RISC-V特有的伪指令 92
    5.6　实验 92
        5.6.1　实验5-1：汇编语言练习—查找最大数 92
        5.6.2　实验5-2：汇编语言练习—通过C语言调用汇编函数 92
        5.6.3　实验5-3：汇编语言练习—通过汇编语言调用C函数 92
        5.6.4　实验5-4：使用汇编伪操作实现一张表 92
        5.6.5　实验5-5：汇编宏的使用 93
第6章　链接器与链接脚本 94
    6.1　链接器 94
    6.2　链接脚本 95
        6.2.1　一个简单的链接程序 95
        6.2.2　设置入口点 96
        6.2.3　基本概念 97
        6.2.4　符号赋值与引用 97
        6.2.5　当前位置计数器 98
        6.2.6　SECTIONS命令 99
        6.2.7　常用的内置函数 101
    6.3　加载重定位 103
        6.3.1　BenOS重定位 103
        6.3.2　OpenSBI和Linux内核重定位 105
    6.4　链接重定位与链接器松弛优化 108
        6.4.1　链接重定位 108
        6.4.2　函数跳转优化 112
        6.4.3　符号地址访问优化 114
    6.5　实验 116
        6.5.1　实验6-1：分析链接脚本 116
        6.5.2　实验6-2：输出每个段的内存布局 116
        6.5.3　实验6-3：加载地址不等于运行地址 117
        6.5.4　实验6-4：设置链接地址 117
        6.5.5　实验6-5：链接器松弛优化1 117
        6.5.6　实验6-6：链接器松弛优化2 117
        6.5.7　实验6-7：分析Linux 5.15内核的链接脚本 117
第7章　内嵌汇编代码 118
    7.1　内嵌汇编代码基本用法 118
    7.2　案例分析 124
    7.3　注意事项 128
    7.4　实验 128
第8章　异常处理 130
    8.1　异常处理基本概念 130
    8.2　与M模式相关的异常寄存器 133
    8.3　与S模式相关的异常寄存器 137
    8.4　异常上下文 139
    8.5　案例分析8-1：实现SBI系统调用 142
    8.6　案例分析8-2：BenOS的异常处理 148
    8.7　实验 154
第9章　中断处理与中断控制器 156
    9.1　中断处理基本概念 156
    9.2　CLINT 159
    9.3　案例分析9-1：定时器中断 160
    9.4　PLIC 164
    9.5　案例分析9-2：串口中断 167
    9.6　实验 171
第10章　内存管理 172
    10.1　内存管理基础知识 172
    10.2　RISC-V内存管理 178
    10.3　物理内存属性与物理内存保护 187
    10.4　案例分析10-1：在BenOS里实现恒等映射 190
    10.5　内存管理实验 204
第11章　高速缓存 207
    11.1　为什么需要高速缓存 207
    11.2　高速缓存的访问延时 208
    11.3　高速缓存的工作原理 210
    11.4　高速缓存的映射方式 212
    11.5　虚拟高速缓存与物理高速缓存 215
    11.6　重名和同名问题 216
    11.7　高速缓存策略 220
    11.8　高速缓存的维护指令 221
第12章　缓存一致性 224
    12.1　为什么需要缓存一致性 224
    12.2　缓存一致性的分类 225
    12.3　缓存一致性的解决方案 227
    12.4　MESI协议 228
    12.5　高速缓存伪共享 237
    12.6　两种缓存一致性控制器 239
    12.7　案例分析12-1：伪共享的避免 241
    12.8　案例分析12-2：DMA和高速缓存的一致性 242
    12.9　案例分析12-3：自修改代码的一致性 244
    12.10　实验 245
第13章　TLB管理 246
    13.1　TLB基础知识 247
    13.2　TLB重名与同名问题 249
    13.3　ASID 251
    13.4　TLB管理指令 253
    13.5　TLB案例分析 256
第14章　原子操作 261
    14.1　原子操作介绍 261
    14.2　保留加载与条件存储指令 262
    14.3　独占内存访问工作原理 263
    14.4　原子内存访问操作指令 266
    14.5　比较并交换操作 270
第15章　内存屏障指令 275
    15.1　内存屏障指令产生的原因 275
    15.2　RISC-V约束条件 280
    15.3　RISC-V中的内存屏障指令 284
    15.4　RISC-V内存屏障指令移植指南 286
    15.5　案例分析 288
    15.6　模拟和测试内存屏障故障 291
    15.7　实验 297
第16章　合理使用内存屏障指令 299
    16.1　存储缓冲区与写内存屏障指令 300
    16.2　无效队列与读内存屏障指令 305
    16.3　内存屏障指令总结 307
    16.4　案例分析：Linux内核中的内存屏障指令 308
    16.5　实验 315
第17章　与操作系统相关的内容 316
    17.1　C语言常见陷阱 317
    17.2　创建进程 320
    17.3　简易进程调度器 327
    17.4　让进程运行在用户模式 335
    17.5　系统调用 338
    17.6　实现clone系统调用 341
    17.7　实验 343
第18章　可伸缩矢量计算与优化 345
    18.1　矢量计算基本概念 345
    18.2　RVV寄存器 348
    18.3　配置编译和运行环境 351
    18.4　RVV指令格式 357
    18.5　配置指令 358
    18.6　加载和存储指令 360
    18.7　矢量掩码指令 369
    18.8　矢量整型算术指令 372
    18.9　案例分析18-1：使用RVV指令优化strcmp()函数 377
    18.10　案例分析18-2：RGB24转BGR24 380
    18.11　案例分析18-3：4 × 4矩阵乘法运算 382
    18.12　案例分析18-4：使用RVV内置函数 388
    18.13　案例分析18-5：自动矢量优化 388
    18.14　术语 390
    18.15　实验 391
第19章　压缩指令扩展 393
    19.1　RISC-V指令集的特点 393
    19.2　RVC支持的指令格式与指令编码 394
第20章　虚拟化扩展 396
    20.1　虚拟化技术介绍 396
    20.2　RISC-V虚拟化扩展 399
    20.3　RISC-V内存虚拟化 404
    20.4　RISC-V虚拟化扩展中的新增指令 406
    20.5　进入和退出虚拟机 407
    20.6　中断虚拟化 410
    20.7　案例分析20-1：进入和退出虚拟机 412
    20.8　案例分析20-2：建立虚拟化两阶段地址映射 415
    20.9　案例分析20-3：在虚拟机中实现虚拟定时器 420
    20.10　案例分析20-4：在VMM中加载和存储虚拟机内存地址 422
    20.11　案例分析20-5：在VMM中模拟串口设备 424
    20.12　实验 429
附录A　关于RISC-V体系结构自测题的参考答案与提示 431
附录B　RV64I指令速查表 433
附录C　RV64M指令速查表 437
附录D　RV64常用伪指令速查表 439